type Sudoku<N> = field[N][N];

def validateValue<N>(field value) -> bool {
	field mut iter = 1;
	field mut res = 1;

	for u32 i in 0..N {
		res = res * (value - iter);
		iter = iter + 1;
	}

	return res == 0;
}

def validateSolution<N>(Sudoku<N> sudoku) -> bool {
	bool mut res = true;
	for u32 i in 0..N {
		for u32 j in 0..N {
			res = res && validateValue::<N>(sudoku[i][j]);
		}
	}
	return res;
}

def distinctRows<N>(Sudoku<N> sudoku) -> bool {
	bool mut res = true;
	for u32 i in 0..N {
		for u32 j1 in 0..N {
			for u32 j2 in 0..j1 {
				res = res && (sudoku[i][j1] != sudoku[i][j2]);
			}
		}
	}
	return res;
}

def solutionMatchesPuzzle<N>(Sudoku<N> puzzle, Sudoku<N> solution) -> bool {
	bool mut res = true;
	for u32 i in 0..N {
		for u32 j in 0..N {
			res = res && (solution[i][j] == puzzle[i][j] || puzzle[i][j] == 0);
		}
	}
	return res;
}

def main(Sudoku<2> puzzle, private Sudoku<2> solution) {
	// Should also assert that the puzzle is a valid puzzle (same check, but also allow 0 as a value)?
	// Not sure because puzzle is public so it can be checked separately that it's a valid puzzle, so maybe
	// it's better to keep it outside of the circuit for the sake of a smaller circuit?

	assert(validateSolution(solution));
	assert(distinctRows(solution));
	assert(solutionMatchesPuzzle(puzzle, solution));
}
